<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tebak Gambar (100 Kata)</title>
    
    <!-- React & Tailwind -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PeerJS -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    
    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        body { font-family: 'Segoe UI', sans-serif; background-color: #f0fdf4; overscroll-behavior: none; }
        canvas { touch-action: none; cursor: crosshair; }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-presets="env,react">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- KONFIGURASI SPREADSHEET ---
        const GOOGLE_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbxqq611KwVynyDLB6XM5wzQlhLj-kLVVhu9pd0cGSt4zIintGUUJufUTiWciUA2CohS/exec"; 

        // --- 100 KATA TEBAKAN ---
        const DEFAULT_WORDS = [
            // Hewan
            "KUCING", "ANJING", "AYAM", "SAPI", "KAMBING", "GAJAH", "SINGA", "HARIMAU", "MONYET", "ULAR",
            "IKAN", "BURUNG", "KUPU-KUPU", "LEBAH", "NYAMUK", "KELINCI", "KUDA", "JERAPAH", "ZEBRA", "BUAYA",
            "DOLPHIN", "HIU", "PANDA", "BERUANG", "KANGURU", "SEMUT", "LABA-LABA", "BEBEK", "DOMBA", "TIKUS",
            // Benda Rumah
            "MEJA", "KURSI", "LEMARI", "KASUR", "JAM", "LAMPU", "KIPAS ANGIN", "TELEVISI", "KOMPUTER", "LAPTOP",
            "HP", "BUKU", "PENSIL", "PULPEN", "PENGHAPUS", "TAS", "SEPATU", "BAJU", "CELANA", "TOPI",
            "PIRING", "GELAS", "SENDOK", "GARPU", "PISAU", "PANCI", "KOMPOR", "SAPU", "PEL", "EMBER",
            // Transportasi
            "MOBIL", "MOTOR", "SEPEDA", "BUS", "KERETA API", "PESAWAT", "KAPAL", "TRUK", "HELIKOPTER", "BECAK",
            // Tempat
            "RUMAH", "SEKOLAH", "KANTOR", "RUMAH SAKIT", "BANDARA", "STASIUN", "PASAR", "TAMAN", "PANTAI", "GUNUNG",
            // Makanan
            "NASI GORENG", "SATE", "BAKSO", "MIE AYAM", "PIZZA", "BURGER", "ES KRIM", "COKLAT", "ROTI", "SUSU",
            // Profesi
            "DOKTER", "POLISI", "GURU", "TENTARA", "PILOT", "PETANI", "NELAYAN", "KOKI", "PENYANYI", "PELUKIS",
            // Alam
            "MATAHARI", "BULAN", "BINTANG", "AWAN", "HUJAN", "PELANGI", "PETIR", "API", "AIR", "TANAH"
        ];
        
        // --- UTILS ---
        const generateRoomId = () => 'room-' + Math.floor(Math.random() * 9000 + 1000);

        // --- COMPONENTS ---

        // 1. LOBBY
        const Lobby = ({ onHost, onJoin, isConnecting }) => {
            const [roomIdInput, setRoomIdInput] = useState("");
            const [myDisplayName, setMyDisplayName] = useState("");

            return (
                <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-green-400 to-emerald-600 p-4">
                    <div className="bg-white p-6 md:p-8 rounded-2xl shadow-2xl w-full max-w-md text-center">
                        <div className="mb-4 bg-green-100 w-16 h-16 md:w-20 md:h-20 rounded-full flex items-center justify-center mx-auto">
                            <i className="fa-solid fa-shapes text-2xl md:text-3xl text-green-600"></i>
                        </div>
                        <h1 className="text-2xl md:text-3xl font-extrabold text-gray-800 mb-1">Tebak Gambar</h1>
                        <p className="text-gray-500 mb-6 text-sm">Main Bareng Tanpa Login</p>
                        
                        <div className="space-y-4">
                            <input 
                                type="text" placeholder="Nama Panggilan"
                                className="w-full px-4 py-3 rounded-lg border-2 border-gray-200 focus:border-green-500 outline-none text-center font-bold"
                                value={myDisplayName} onChange={e => setMyDisplayName(e.target.value)}
                            />

                            <div className="border-t pt-4">
                                <button 
                                    onClick={() => onHost(myDisplayName)}
                                    disabled={!myDisplayName || isConnecting}
                                    className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-lg transition-all disabled:opacity-50 shadow-lg shadow-green-200"
                                >
                                    {isConnecting ? "Memproses..." : "Buat Game Baru (Host)"}
                                </button>
                            </div>

                            <div className="relative flex py-2 items-center">
                                <div className="flex-grow border-t border-gray-200"></div>
                                <span className="flex-shrink mx-4 text-gray-400 text-xs">GABUNG TEMAN</span>
                                <div className="flex-grow border-t border-gray-200"></div>
                            </div>

                            <div className="flex gap-2">
                                <input 
                                    type="text" placeholder="ID Room"
                                    className="flex-1 px-4 py-3 rounded-lg border-2 border-gray-200 focus:border-blue-500 outline-none uppercase font-mono"
                                    value={roomIdInput} onChange={e => setRoomIdInput(e.target.value)}
                                />
                                <button 
                                    onClick={() => onJoin(roomIdInput, myDisplayName)}
                                    disabled={!myDisplayName || !roomIdInput || isConnecting}
                                    className="bg-blue-600 hover:bg-blue-700 text-white font-bold px-6 rounded-lg disabled:opacity-50 shadow-lg shadow-blue-200"
                                >
                                    Join
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // 2. CANVAS
        const CanvasBoard = ({ isDrawer, color, width, socket, gameState }) => {
            const canvasRef = useRef(null);
            const ctxRef = useRef(null);
            const parentRef = useRef(null);
            const [isDrawing, setIsDrawing] = useState(false);

            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext("2d");
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctxRef.current = ctx;

                const resize = () => {
                    if (parentRef.current && canvas) {
                        canvas.width = parentRef.current.offsetWidth;
                        canvas.height = parentRef.current.offsetHeight;
                        ctx.lineCap = "round";
                        ctx.lineJoin = "round";
                    }
                };
                resize();
                window.addEventListener('resize', resize);
                // Delay resize to fix mobile init issue
                setTimeout(resize, 100); 
                return () => window.removeEventListener('resize', resize);
            }, []);

            useEffect(() => {
                if (gameState.triggerClear && ctxRef.current && canvasRef.current) {
                    ctxRef.current.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                }
            }, [gameState.triggerClear]);

            const drawLine = (x0, y0, x1, y1, color, size, emit) => {
                const ctx = ctxRef.current;
                if(!ctx) return;
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = size;
                ctx.moveTo(x0, y0);
                ctx.lineTo(x1, y1);
                ctx.stroke();

                if (emit && socket) {
                    const w = canvasRef.current.width;
                    const h = canvasRef.current.height;
                    socket.send({
                        type: 'DRAW',
                        data: { x0: x0/w, y0: y0/h, x1: x1/w, y1: y1/h, color, size }
                    });
                }
            };

            useEffect(() => {
                if (!socket) return;
                const handleData = (payload) => {
                    if (payload.type === 'DRAW') {
                        const { x0, y0, x1, y1, color, size } = payload.data;
                        const w = canvasRef.current.width;
                        const h = canvasRef.current.height;
                        drawLine(x0*w, y0*h, x1*w, y1*h, color, size, false);
                    }
                    if (payload.type === 'CLEAR') {
                        const ctx = ctxRef.current;
                        ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                    }
                };
                socket.onData(handleData);
                return () => socket.offData(handleData);
            }, [socket]);

            const lastPos = useRef(null);
            const getPos = (e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return { x: clientX - rect.left, y: clientY - rect.top };
            };

            const start = (e) => {
                if (!isDrawer) return;
                setIsDrawing(true);
                lastPos.current = getPos(e);
            };

            const move = (e) => {
                if (!isDrawer || !isDrawing) return;
                e.preventDefault();
                const newPos = getPos(e);
                if (lastPos.current) {
                    drawLine(lastPos.current.x, lastPos.current.y, newPos.x, newPos.y, color, width, true);
                }
                lastPos.current = newPos;
            };

            const end = () => { setIsDrawing(false); lastPos.current = null; };

            return (
                <div ref={parentRef} className="w-full h-full bg-white rounded-lg shadow-inner overflow-hidden relative touch-none bg-[url('https://www.transparenttextures.com/patterns/graphy.png')]">
                    <canvas 
                        ref={canvasRef} 
                        className="block cursor-crosshair"
                        onMouseDown={start} onMouseMove={move} onMouseUp={end} onMouseLeave={end}
                        onTouchStart={start} onTouchMove={move} onTouchEnd={end}
                    />
                    {!isDrawer && <div className="absolute top-2 right-2 bg-black/50 text-white text-xs px-2 py-1 rounded pointer-events-none">Mode Penonton</div>}
                </div>
            );
        };

        // 3. MAIN APP
        const App = () => {
            const [view, setView] = useState("lobby");
            const [myId, setMyId] = useState(null);
            const [myName, setMyName] = useState("");
            const [isHost, setIsHost] = useState(false);
            const [connections, setConnections] = useState([]);
            const [status, setStatus] = useState("");
            
            const [gameState, setGameState] = useState({
                roomId: "",
                players: [],
                chat: [],
                phase: "waiting",
                drawerId: null,
                word: "",
                timer: 0,
                round: 0,
                triggerClear: 0
            });

            const [brushColor, setBrushColor] = useState("#000000");
            const [brushSize, setBrushSize] = useState(4);
            const socketRef = useRef({
                send: () => {},
                listeners: [],
                onData: (fn) => socketRef.current.listeners.push(fn),
                offData: (fn) => socketRef.current.listeners = socketRef.current.listeners.filter(l => l !== fn),
                trigger: (data) => socketRef.current.listeners.forEach(fn => fn(data))
            });

            const [wordList, setWordList] = useState(DEFAULT_WORDS);

            const fetchWordsFromSheet = async () => {
                if (!GOOGLE_SCRIPT_URL) return;
                try {
                    const res = await fetch(GOOGLE_SCRIPT_URL + "?action=getWords");
                    const data = await res.json();
                    if (Array.isArray(data) && data.length > 0) setWordList(data);
                } catch (e) { console.error("Gagal muat kata", e); }
            };

            const saveScoreToSheet = async (winnerName, score, room) => {
                if (!GOOGLE_SCRIPT_URL) return;
                try {
                    const url = `${GOOGLE_SCRIPT_URL}?action=saveScore&winnerName=${encodeURIComponent(winnerName)}&score=${score}&room=${room}`;
                    fetch(url, { method: "POST" });
                } catch (e) { console.error("Gagal simpan skor", e); }
            };

            const initPeer = (name, roomId, isHostRole) => {
                setMyName(name);
                setIsHost(isHostRole);
                setStatus("Menghubungkan...");

                const myPeerId = isHostRole ? roomId : null;
                const peer = new Peer(myPeerId);

                peer.on('open', (id) => {
                    setMyId(id);
                    setStatus("Online");
                    if (isHostRole) {
                        setGameState(prev => ({ ...prev, roomId: id, players: [{id: id, name: name, score: 0}] }));
                        fetchWordsFromSheet();
                        setView("game");
                    } else {
                        const conn = peer.connect(roomId, { metadata: { name: name } });
                        setupConnection(conn, false);
                    }
                });

                peer.on('connection', (conn) => { if (isHostRole) setupConnection(conn, true); });
                peer.on('error', (err) => { alert("Gagal konek: " + err.type); setStatus("Error"); setView("lobby"); });
            };

            const setupConnection = (conn, amIHost) => {
                conn.on('open', () => {
                    setConnections(prev => [...prev, conn]);
                    if (amIHost) {
                        const newPlayer = { id: conn.peer, name: conn.metadata.name || "Guest", score: 0 };
                        setGameState(prev => {
                            const newState = { ...prev, players: [...prev.players, newPlayer] };
                            broadcast(newState);
                            return newState;
                        });
                    } else {
                        setView("game");
                    }
                });
                conn.on('data', (data) => {
                    if (data.type === 'SYNC_STATE') setGameState(data.state);
                    else if (data.type === 'DRAW') {
                        socketRef.current.trigger(data);
                        if (amIHost) broadcast(data, conn.peer);
                    } else if (data.type === 'CHAT') handleChat(data, amIHost);
                    else if (data.type === 'CLEAR') {
                         socketRef.current.trigger(data);
                         if (amIHost) broadcast(data, conn.peer);
                    }
                });
                conn.on('close', () => { setConnections(prev => prev.filter(c => c !== conn)); });
            };

            const broadcast = (data, excludePeerId = null) => {
                connections.forEach(conn => {
                    if (conn.peer !== excludePeerId && conn.open) {
                        if (data.roomId) conn.send({ type: 'SYNC_STATE', state: data });
                        else conn.send(data);
                    }
                });
            };

            socketRef.current.send = (data) => {
                if (isHost) {
                    if (data.type === 'DRAW' || data.type === 'CLEAR') {
                         socketRef.current.trigger(data);
                         broadcast(data);
                    } else if (data.type === 'CHAT') handleChat(data, true);
                } else {
                    const hostConn = connections[0];
                    if (hostConn) hostConn.send(data);
                    if (data.type === 'DRAW' || data.type === 'CLEAR') socketRef.current.trigger(data);
                }
            };

            const startGame = () => {
                if (!isHost) return;
                const players = gameState.players;
                const drawer = players[Math.floor(Math.random() * players.length)];
                const word = wordList[Math.floor(Math.random() * wordList.length)];
                
                const newState = {
                    ...gameState,
                    phase: "playing",
                    drawerId: drawer.id,
                    word: word,
                    timer: 60,
                    round: gameState.round + 1,
                    chat: [...gameState.chat, { text: `Ronde ${gameState.round + 1} dimulai!`, type: 'system' }],
                    triggerClear: gameState.triggerClear + 1
                };
                setGameState(newState);
                broadcast(newState);
                socketRef.current.trigger({ type: 'CLEAR' });
            };

            useEffect(() => {
                if (!isHost || gameState.phase !== 'playing') return;
                const interval = setInterval(() => {
                    setGameState(prev => {
                        if (prev.timer <= 1) {
                            const nextState = { ...prev, phase: 'result', timer: 5, chat: [...prev.chat, { text: `Waktu habis! Jawaban: ${prev.word}`, type: 'system' }] };
                            broadcast(nextState);
                            return nextState;
                        }
                        const nextState = { ...prev, timer: prev.timer - 1 };
                        broadcast(nextState);
                        return nextState;
                    });
                }, 1000);
                return () => clearInterval(interval);
            }, [isHost, gameState.phase, gameState.timer]);

            useEffect(() => {
                if (!isHost || gameState.phase !== 'result') return;
                if (gameState.timer <= 0) {
                     const nextState = { ...gameState, phase: 'waiting', drawerId: null, word: "" };
                     setGameState(nextState);
                     broadcast(nextState);
                }
            }, [isHost, gameState.phase, gameState.timer]);

            const handleChat = (payload, amIHost) => {
                const { senderName, text, senderId } = payload;
                const isCorrect = gameState.phase === 'playing' && text.toUpperCase() === gameState.word.toUpperCase() && senderId !== gameState.drawerId;
                
                let newChatMsg = { senderName, text, type: 'user' };

                if (isCorrect) {
                    newChatMsg = { text: `${senderName} BENAR! (+10)`, type: 'success' };
                    if (amIHost) {
                        setGameState(prev => {
                            const updatedPlayers = prev.players.map(p => {
                                if (p.id === senderId) {
                                    saveScoreToSheet(p.name, p.score + 10, prev.roomId);
                                    return { ...p, score: p.score + 10 };
                                }
                                if (p.id === gameState.drawerId) return { ...p, score: p.score + 5 };
                                return p;
                            });
                            const newState = { ...prev, chat: [...prev.chat, newChatMsg], players: updatedPlayers, phase: 'result', timer: 5 };
                            broadcast(newState);
                            return newState;
                        });
                    }
                } else {
                    if (amIHost) {
                        setGameState(prev => {
                            const newState = { ...prev, chat: [...prev.chat, newChatMsg] };
                            broadcast(newState);
                            return newState;
                        });
                    }
                }
            };

            const sendChat = (text) => {
                if (!text.trim()) return;
                socketRef.current.send({ type: 'CHAT', text, senderName: myName, senderId: myId });
            };

            if (view === "lobby") return <Lobby onHost={(n) => initPeer(n, generateRoomId(), true)} onJoin={(id, n) => initPeer(n, id, false)} isConnecting={status.includes("Menghubungkan")} />;

            const isDrawer = myId === gameState.drawerId;
            const hiddenWord = gameState.word.replace(/[a-zA-Z]/g, "_ ");

            return (
                <div className="flex flex-col h-screen max-w-7xl mx-auto bg-gray-50 shadow-2xl">
                    {/* Header */}
                    <div className="bg-white px-4 py-3 shadow flex justify-between items-center z-10 shrink-0">
                        <div className="flex items-center gap-3">
                            <div className="bg-gray-800 text-white w-10 h-10 rounded-full flex items-center justify-center font-bold text-lg">{gameState.timer}</div>
                            <div>
                                {gameState.phase === 'playing' ? (
                                    isDrawer ? 
                                    <div className="text-sm md:text-lg font-bold text-green-600">GAMBAR: {gameState.word}</div> : 
                                    <div className="text-lg md:text-2xl font-mono tracking-widest bg-gray-200 px-3 py-1 rounded font-bold">{hiddenWord}</div>
                                ) : <div className="text-gray-500 text-sm font-medium">Menunggu...</div>}
                            </div>
                        </div>
                        <div className="text-xs bg-gray-100 px-2 py-1 rounded font-mono border">ID: {gameState.roomId}</div>
                    </div>

                    {/* Layout Utama: Kolom di HP, Baris di Desktop */}
                    <div className="flex flex-1 overflow-hidden flex-col md:flex-row">
                        
                        {/* Sidebar Pemain (Desktop Only) */}
                        <div className="hidden md:block w-56 bg-white border-r p-2 overflow-y-auto shrink-0">
                            <div className="text-xs font-bold text-gray-400 mb-2 uppercase">Pemain ({gameState.players.length})</div>
                            {gameState.players.sort((a,b)=>b.score-a.score).map(p => (
                                <div key={p.id} className={`flex items-center p-2 rounded mb-1 ${p.id === gameState.drawerId ? 'bg-yellow-50 border border-yellow-200' : 'bg-gray-50'}`}>
                                    <div className="w-8 h-8 rounded-full bg-blue-100 flex items-center justify-center text-xs font-bold mr-2 text-blue-600">{p.name[0]}</div>
                                    <div className="overflow-hidden min-w-0">
                                        <div className="font-bold text-sm truncate">{p.name}</div>
                                        <div className="text-xs text-gray-500">{p.score} Pts</div>
                                    </div>
                                    {p.id === gameState.drawerId && <i className="fa-solid fa-pencil text-yellow-500 ml-auto"></i>}
                                </div>
                            ))}
                        </div>

                        {/* Area Canvas (Flexible) */}
                        <div className="flex-1 bg-gray-100 p-2 md:p-4 flex flex-col relative min-h-0">
                            
                            {/* OVERLAY KHUSUS PENGGAMBAR */}
                            {isDrawer && gameState.phase === 'playing' && (
                                <div className="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-800 p-3 mb-2 rounded shadow-sm flex items-center justify-between animate-pulse">
                                    <div className="font-bold">GILIRAN KAMU! GAMBAR: <span className="text-2xl ml-2 uppercase text-black">{gameState.word}</span></div>
                                    <i className="fa-solid fa-pencil text-xl"></i>
                                </div>
                            )}

                            {/* Result Overlay */}
                            {gameState.phase === 'result' && (
                                <div className="absolute inset-0 bg-black/80 z-30 flex flex-col items-center justify-center text-white backdrop-blur-sm p-4 text-center">
                                    <div className="text-xl mb-2 opacity-80">Jawabannya adalah</div>
                                    <div className="text-4xl md:text-5xl font-black text-green-400 mb-6 uppercase tracking-wider">{gameState.word}</div>
                                    <div className="bg-white/10 px-4 py-2 rounded-full text-sm">Ronde baru sebentar lagi...</div>
                                </div>
                            )}

                            {/* Start Button Overlay */}
                            {gameState.phase === 'waiting' && isHost && (
                                <div className="absolute inset-0 bg-white/80 z-30 flex items-center justify-center backdrop-blur-sm">
                                    <button onClick={startGame} className="bg-green-600 hover:bg-green-700 text-white text-xl font-bold py-4 px-10 rounded-full shadow-xl transform transition hover:scale-105">
                                        MULAI GAME
                                    </button>
                                </div>
                            )}

                            <div className="flex-1 bg-white rounded-lg shadow border border-gray-300 overflow-hidden relative">
                                <CanvasBoard 
                                    isDrawer={isDrawer && gameState.phase === 'playing'}
                                    color={brushColor}
                                    width={brushSize}
                                    socket={socketRef.current}
                                    gameState={gameState}
                                />
                            </div>

                            {/* Toolbar (Drawer Only) */}
                            {isDrawer && gameState.phase === 'playing' && (
                                <div className="bg-white p-2 mt-2 rounded-lg shadow-sm border flex justify-between items-center gap-2 overflow-x-auto">
                                    <div className="flex gap-1 shrink-0">
                                        {['#000000', '#ef4444', '#22c55e', '#3b82f6', '#eab308'].map(c => (
                                            <button key={c} onClick={() => setBrushColor(c)} className={`w-7 h-7 md:w-8 md:h-8 rounded-full border-2 ${brushColor === c ? 'border-gray-800 scale-110' : 'border-transparent'}`} style={{backgroundColor: c}} />
                                        ))}
                                    </div>
                                    <div className="flex items-center gap-2 shrink-0">
                                        <input type="range" min="2" max="20" value={brushSize} onChange={(e) => setBrushSize(parseInt(e.target.value))} className="w-20 md:w-24 accent-gray-800" />
                                        <button onClick={() => socketRef.current.send({type: 'CLEAR'})} className="text-red-500 hover:bg-red-50 p-2 rounded"><i className="fa-solid fa-trash"></i></button>
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* Chat & Guessing Area (Fixed Height on Mobile) */}
                        <div className="h-[35vh] md:h-auto md:w-80 bg-white border-t md:border-t-0 md:border-l flex flex-col shadow-[0_-5px_15px_rgba(0,0,0,0.05)] md:shadow-none z-20 shrink-0">
                            <div className="p-2 md:p-3 bg-gray-50 border-b font-bold text-gray-700 text-sm flex items-center gap-2">
                                <i className="fa-regular fa-comments"></i> Obrolan & Tebakan
                            </div>
                            <div className="flex-1 overflow-y-auto p-2 space-y-2 flex flex-col-reverse bg-slate-50">
                                {[...gameState.chat].reverse().map((msg, i) => (
                                    <div key={i} className={`text-sm px-3 py-1.5 rounded-lg border ${msg.type === 'system' ? 'bg-blue-50 text-blue-800 border-blue-100 text-center text-xs font-bold uppercase' : msg.type === 'success' ? 'bg-green-100 text-green-800 border-green-200 text-center font-bold' : 'bg-white border-gray-100'}`}>
                                        {msg.type === 'user' && <span className="font-bold text-gray-800 mr-1">{msg.senderName}:</span>}
                                        {msg.text}
                                    </div>
                                ))}
                            </div>
                            <div className="p-2 md:p-3 bg-white border-t">
                                <div className="relative">
                                    <input 
                                        type="text" 
                                        placeholder={isDrawer ? "Anda sedang menggambar..." : "Ketik jawaban di sini..."}
                                        className="w-full border-2 border-gray-200 rounded-full px-4 py-2 pr-10 focus:border-blue-500 focus:outline-none transition-colors disabled:bg-gray-100"
                                        disabled={isDrawer && gameState.phase === 'playing'}
                                        onKeyDown={(e) => { if(e.key === 'Enter') { sendChat(e.target.value); e.target.value = ''; } }}
                                        autoComplete="off"
                                    />
                                    <button className="absolute right-3 top-1/2 -translate-y-1/2 text-blue-500 hover:text-blue-600 disabled:text-gray-300">
                                        <i className="fa-solid fa-paper-plane"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById("root"));
        root.render(<App />);
    </script>
</body>
</html>
