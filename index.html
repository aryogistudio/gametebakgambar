<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tebak Gambar (Sheets + P2P)</title>
    
    <!-- React & Tailwind -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PeerJS (Pengganti Firebase Realtime) -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    
    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        body { font-family: 'Segoe UI', sans-serif; background-color: #f0fdf4; overscroll-behavior: none; }
        canvas { touch-action: none; cursor: crosshair; }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        @keyframes pulse-ring { 0% { transform: scale(0.8); opacity: 0.5; } 100% { transform: scale(2); opacity: 0; } }
        .ring-animate::before { content: ''; position: absolute; left: 0; top: 0; right: 0; bottom: 0; border-radius: 50%; border: 2px solid #22c55e; animation: pulse-ring 2s infinite; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-presets="env,react">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- KONFIGURASI SPREADSHEET ---
        // GANTI URL INI DENGAN URL DEPLOYMENT GOOGLE APPS SCRIPT ANDA
        // Jika kosong, game akan menggunakan kata-kata default lokal.
        const GOOGLE_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbxqq611KwVynyDLB6XM5wzQlhLj-kLVVhu9pd0cGSt4zIintGUUJufUTiWciUA2CohS/exec"; 

        // --- DEFAULT WORDS (BACKUP) ---
        const DEFAULT_WORDS = ["KUCING", "RUMAH", "MOBIL", "MATAHARI", "POHON", "KOMPUTER", "TELEPON"];
        
        // --- PEERJS UTILS ---
        // Helper untuk membuat ID acak yang mudah dibaca (misal: "mabar-123")
        const generateRoomId = () => 'room-' + Math.floor(Math.random() * 9000 + 1000);

        // --- COMPONENTS ---

        // 1. LOBBY & MENU
        const Lobby = ({ onHost, onJoin, isConnecting }) => {
            const [roomIdInput, setRoomIdInput] = useState("");
            const [myDisplayName, setMyDisplayName] = useState("");

            return (
                <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-green-400 to-emerald-600 p-4">
                    <div className="bg-white p-8 rounded-2xl shadow-2xl w-full max-w-md text-center">
                        <div className="mb-4 bg-green-100 w-20 h-20 rounded-full flex items-center justify-center mx-auto">
                            <i className="fa-solid fa-shapes text-3xl text-green-600"></i>
                        </div>
                        <h1 className="text-3xl font-extrabold text-gray-800 mb-1">Tebak Gambar</h1>
                        <p className="text-gray-500 mb-6 text-sm">P2P Real-time + Google Sheets</p>
                        
                        <div className="space-y-4">
                            <input 
                                type="text" placeholder="Nama Anda"
                                className="w-full px-4 py-3 rounded-lg border-2 border-gray-200 focus:border-green-500 outline-none text-center font-bold"
                                value={myDisplayName} onChange={e => setMyDisplayName(e.target.value)}
                            />

                            <div className="border-t pt-4">
                                <p className="text-xs text-gray-400 mb-2 font-bold uppercase">Buat Room Baru</p>
                                <button 
                                    onClick={() => onHost(myDisplayName)}
                                    disabled={!myDisplayName || isConnecting}
                                    className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-lg transition-all disabled:opacity-50"
                                >
                                    {isConnecting ? "Memproses..." : "Buat Game Baru (Host)"}
                                </button>
                            </div>

                            <div className="relative flex py-2 items-center">
                                <div className="flex-grow border-t border-gray-200"></div>
                                <span className="flex-shrink mx-4 text-gray-400 text-xs">ATAU GABUNG</span>
                                <div className="flex-grow border-t border-gray-200"></div>
                            </div>

                            <div className="flex gap-2">
                                <input 
                                    type="text" placeholder="ID Room (ex: room-1234)"
                                    className="flex-1 px-4 py-3 rounded-lg border-2 border-gray-200 focus:border-blue-500 outline-none uppercase"
                                    value={roomIdInput} onChange={e => setRoomIdInput(e.target.value)}
                                />
                                <button 
                                    onClick={() => onJoin(roomIdInput, myDisplayName)}
                                    disabled={!myDisplayName || !roomIdInput || isConnecting}
                                    className="bg-blue-600 hover:bg-blue-700 text-white font-bold px-6 rounded-lg disabled:opacity-50"
                                >
                                    Join
                                </button>
                            </div>
                        </div>
                        {isConnecting && <p className="text-xs text-green-600 mt-4 animate-pulse">Menghubungkan ke server P2P...</p>}
                    </div>
                </div>
            );
        };

        // 2. CANVAS BOARD
        const CanvasBoard = ({ isDrawer, color, width, socket, gameState }) => {
            const canvasRef = useRef(null);
            const ctxRef = useRef(null);
            const [isDrawing, setIsDrawing] = useState(false);

            // Init Canvas
            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext("2d");
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctxRef.current = ctx;

                // Handle resize
                const resize = () => {
                    canvas.width = canvas.parentElement.offsetWidth;
                    canvas.height = canvas.parentElement.offsetHeight;
                    ctx.lineCap = "round";
                    ctx.lineJoin = "round";
                };
                resize();
                window.addEventListener('resize', resize);
                return () => window.removeEventListener('resize', resize);
            }, []);

            // Handle Clear Canvas Event
            useEffect(() => {
                if (gameState.triggerClear && ctxRef.current && canvasRef.current) {
                    ctxRef.current.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                }
            }, [gameState.triggerClear]);

            // Draw Logic
            const drawLine = (x0, y0, x1, y1, color, size, emit) => {
                const ctx = ctxRef.current;
                if(!ctx) return;
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = size;
                ctx.moveTo(x0, y0);
                ctx.lineTo(x1, y1);
                ctx.stroke();

                if (emit && socket) {
                    // Send relative coordinates (0-1) to support different screen sizes
                    const w = canvasRef.current.width;
                    const h = canvasRef.current.height;
                    socket.send({
                        type: 'DRAW',
                        data: { x0: x0/w, y0: y0/h, x1: x1/w, y1: y1/h, color, size }
                    });
                }
            };

            // Listen for remote draw events
            useEffect(() => {
                if (!socket) return;
                const handleData = (payload) => {
                    if (payload.type === 'DRAW') {
                        const { x0, y0, x1, y1, color, size } = payload.data;
                        const w = canvasRef.current.width;
                        const h = canvasRef.current.height;
                        drawLine(x0*w, y0*h, x1*w, y1*h, color, size, false);
                    }
                    if (payload.type === 'CLEAR') {
                        const ctx = ctxRef.current;
                        ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                    }
                };
                
                // Add listener to socket object wrapper
                socket.onData(handleData);
                return () => socket.offData(handleData);
            }, [socket]);

            // Mouse/Touch Handlers
            const lastPos = useRef(null);
            const getPos = (e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return { x: clientX - rect.left, y: clientY - rect.top };
            };

            const start = (e) => {
                if (!isDrawer) return;
                setIsDrawing(true);
                lastPos.current = getPos(e);
            };

            const move = (e) => {
                if (!isDrawer || !isDrawing) return;
                e.preventDefault();
                const newPos = getPos(e);
                if (lastPos.current) {
                    drawLine(lastPos.current.x, lastPos.current.y, newPos.x, newPos.y, color, width, true);
                }
                lastPos.current = newPos;
            };

            const end = () => { setIsDrawing(false); lastPos.current = null; };

            return (
                <div className="w-full h-full bg-white rounded-lg shadow-inner overflow-hidden relative touch-none bg-[url('https://www.transparenttextures.com/patterns/graphy.png')]">
                    <canvas 
                        ref={canvasRef} 
                        className="block cursor-crosshair"
                        onMouseDown={start} onMouseMove={move} onMouseUp={end} onMouseLeave={end}
                        onTouchStart={start} onTouchMove={move} onTouchEnd={end}
                    />
                    {!isDrawer && <div className="absolute top-2 right-2 bg-black/50 text-white text-xs px-2 py-1 rounded">View Only</div>}
                </div>
            );
        };

        // 3. MAIN APP CONTROLLER
        const App = () => {
            const [view, setView] = useState("lobby"); // lobby, game
            const [myId, setMyId] = useState(null);
            const [myName, setMyName] = useState("");
            const [isHost, setIsHost] = useState(false);
            const [peerInstance, setPeerInstance] = useState(null);
            const [connections, setConnections] = useState([]); // List of dataConnections
            const [status, setStatus] = useState("");
            
            // Game State
            const [gameState, setGameState] = useState({
                roomId: "",
                players: [], // {id, name, score}
                chat: [],
                phase: "waiting", // waiting, playing, result
                drawerId: null,
                word: "",
                timer: 0,
                round: 0,
                triggerClear: 0 // Increment to clear
            });

            // Drawing State
            const [brushColor, setBrushColor] = useState("#000000");
            const [brushSize, setBrushSize] = useState(4);

            // Ref for socket wrapper to handle events
            const socketRef = useRef({
                send: () => {},
                listeners: [],
                onData: (fn) => socketRef.current.listeners.push(fn),
                offData: (fn) => socketRef.current.listeners = socketRef.current.listeners.filter(l => l !== fn),
                trigger: (data) => socketRef.current.listeners.forEach(fn => fn(data))
            });

            // --- GOOGLE SHEETS INTEGRATION ---
            const [wordList, setWordList] = useState(DEFAULT_WORDS);

            const fetchWordsFromSheet = async () => {
                if (!GOOGLE_SCRIPT_URL) return;
                try {
                    const res = await fetch(GOOGLE_SCRIPT_URL + "?action=getWords");
                    const data = await res.json();
                    if (Array.isArray(data) && data.length > 0) {
                        setWordList(data);
                        console.log("Kata dimuat dari Sheet:", data);
                    }
                } catch (e) { console.error("Gagal muat kata", e); }
            };

            const saveScoreToSheet = async (winnerName, score, room) => {
                if (!GOOGLE_SCRIPT_URL) return;
                try {
                    // Send async, don't await response
                    const url = `${GOOGLE_SCRIPT_URL}?action=saveScore&winnerName=${encodeURIComponent(winnerName)}&score=${score}&room=${room}`;
                    fetch(url, { method: "POST" }); 
                    console.log("Skor dikirim ke Sheet");
                } catch (e) { console.error("Gagal simpan skor", e); }
            };

            // --- P2P LOGIC ---

            // Initialize Peer
            const initPeer = (name, roomId, isHostRole) => {
                setMyName(name);
                setIsHost(isHostRole);
                setStatus("Menghubungkan ke server P2P...");

                // Create Peer with specific ID if host, or random if joining
                const myPeerId = isHostRole ? roomId : null;
                const peer = new Peer(myPeerId);

                peer.on('open', (id) => {
                    setMyId(id);
                    setPeerInstance(peer);
                    setStatus("Online");
                    
                    if (isHostRole) {
                        // HOST SETUP
                        setGameState(prev => ({
                            ...prev,
                            roomId: id,
                            players: [{id: id, name: name, score: 0}]
                        }));
                        fetchWordsFromSheet(); // Load words only on host
                        setView("game");
                    } else {
                        // JOINER SETUP: Connect to Host
                        const conn = peer.connect(roomId, { metadata: { name: name } });
                        setupConnection(conn, false);
                    }
                });

                peer.on('connection', (conn) => {
                    // Only Host receives connections
                    if (isHostRole) {
                        setupConnection(conn, true);
                    }
                });

                peer.on('error', (err) => {
                    alert("Error: " + err.type);
                    setStatus("Error");
                    setView("lobby");
                });
            };

            // Setup Data Connection
            const setupConnection = (conn, amIHost) => {
                conn.on('open', () => {
                    setConnections(prev => [...prev, conn]);
                    
                    if (amIHost) {
                        // HOST: Add new player
                        const newPlayer = { id: conn.peer, name: conn.metadata.name || "Guest", score: 0 };
                        setGameState(prev => {
                            const newState = { ...prev, players: [...prev.players, newPlayer] };
                            broadcast(newState); // Send full state to everyone
                            return newState;
                        });
                    } else {
                        // CLIENT: Wait for state
                        setView("game");
                    }
                });

                conn.on('data', (data) => {
                    if (data.type === 'SYNC_STATE') {
                        // Client receives full state update
                        setGameState(data.state);
                    } else if (data.type === 'DRAW') {
                        // Drawing data (Host relays to others, Client just draws)
                        socketRef.current.trigger(data);
                        if (amIHost) broadcast(data, conn.peer); // Relay to others
                    } else if (data.type === 'CHAT') {
                        // Chat message
                        handleChat(data, amIHost);
                    } else if (data.type === 'CLEAR') {
                         socketRef.current.trigger(data);
                         if (amIHost) broadcast(data, conn.peer);
                    }
                });

                conn.on('close', () => {
                    setConnections(prev => prev.filter(c => c !== conn));
                    // Handle player disconnect logic if needed
                });
            };

            // Broadcast to all connected peers
            const broadcast = (data, excludePeerId = null) => {
                connections.forEach(conn => {
                    if (conn.peer !== excludePeerId && conn.open) {
                        if (data.roomId) {
                            conn.send({ type: 'SYNC_STATE', state: data });
                        } else {
                            conn.send(data);
                        }
                    }
                });
            };

            // Socket wrapper send function
            socketRef.current.send = (data) => {
                if (isHost) {
                    // Host action
                    if (data.type === 'DRAW' || data.type === 'CLEAR') {
                         socketRef.current.trigger(data); // Draw locally
                         broadcast(data); // Send to all
                    } else if (data.type === 'CHAT') {
                        handleChat(data, true);
                    }
                } else {
                    // Client action: Send to Host
                    const hostConn = connections[0]; // Client only has 1 connection (to Host)
                    if (hostConn) hostConn.send(data);
                    
                    // If chat or draw, process locally immediately for responsiveness
                    if (data.type === 'DRAW' || data.type === 'CLEAR') socketRef.current.trigger(data);
                }
            };

            // --- GAME LOGIC (HOST ONLY) ---
            
            const startGame = () => {
                if (!isHost) return;
                // Pilih drawer acak
                const players = gameState.players;
                const drawer = players[Math.floor(Math.random() * players.length)];
                const word = wordList[Math.floor(Math.random() * wordList.length)];
                
                const newState = {
                    ...gameState,
                    phase: "playing",
                    drawerId: drawer.id,
                    word: word,
                    timer: 60,
                    round: gameState.round + 1,
                    chat: [...gameState.chat, { text: `Round ${gameState.round + 1}: ${drawer.name} menggambar!`, type: 'system' }],
                    triggerClear: gameState.triggerClear + 1
                };
                
                setGameState(newState);
                broadcast(newState);
                socketRef.current.trigger({ type: 'CLEAR' });
            };

            // Timer (Host only)
            useEffect(() => {
                if (!isHost || gameState.phase !== 'playing') return;
                
                const interval = setInterval(() => {
                    setGameState(prev => {
                        if (prev.timer <= 1) {
                            // Time over
                            const nextState = {
                                ...prev,
                                phase: 'result',
                                timer: 5,
                                chat: [...prev.chat, { text: `Waktu habis! Kata: ${prev.word}`, type: 'system' }]
                            };
                            broadcast(nextState);
                            return nextState;
                        }
                        const nextState = { ...prev, timer: prev.timer - 1 };
                        // Optimize: Only broadcast timer every 5 seconds or sync rarely to save bandwidth?
                        // For PeerJS LAN/Good internet, sending every sec is okay.
                        broadcast(nextState);
                        return nextState;
                    });
                }, 1000);
                
                return () => clearInterval(interval);
            }, [isHost, gameState.phase, gameState.timer]); // Timer dependency added for proper closure

            // Auto restart after result
            useEffect(() => {
                if (!isHost || gameState.phase !== 'result') return;
                if (gameState.timer <= 0) {
                     // Back to waiting
                     const nextState = { ...gameState, phase: 'waiting', drawerId: null, word: "" };
                     setGameState(nextState);
                     broadcast(nextState);
                }
            }, [isHost, gameState.phase, gameState.timer]);

            // Handle Chat & Guesses
            const handleChat = (payload, amIHost) => {
                const { senderName, text, senderId } = payload;
                const isCorrect = gameState.phase === 'playing' && text.toUpperCase() === gameState.word.toUpperCase() && senderId !== gameState.drawerId;
                
                let newChatMsg = { senderName, text, type: 'user' };
                let scoreUpdate = null;

                if (isCorrect) {
                    newChatMsg = { text: `${senderName} MENJAWAB BENAR!`, type: 'success' };
                    // Calculate Score
                    scoreUpdate = { winner: senderId, points: 10, drawer: gameState.drawerId };
                    
                    if (amIHost) {
                        // Update scores in state
                        setGameState(prev => {
                            const updatedPlayers = prev.players.map(p => {
                                if (p.id === senderId) {
                                    // Save to sheet when someone wins points
                                    saveScoreToSheet(p.name, p.score + 10, prev.roomId);
                                    return { ...p, score: p.score + 10 };
                                }
                                if (p.id === gameState.drawerId) return { ...p, score: p.score + 5 };
                                return p;
                            });
                            
                            const newState = {
                                ...prev,
                                chat: [...prev.chat, newChatMsg],
                                players: updatedPlayers,
                                phase: 'result', // End round immediately on correct guess
                                timer: 5
                            };
                            broadcast(newState);
                            return newState;
                        });
                    }
                } else {
                    if (amIHost) {
                        setGameState(prev => {
                            const newState = { ...prev, chat: [...prev.chat, newChatMsg] };
                            broadcast(newState); // Relay chat to everyone
                            return newState;
                        });
                    }
                }
                
                // If I am client and I sent it, host will update me via Sync. 
                // But for smoothness, we might want to append locally, but Sync is safer source of truth.
            };

            const sendChat = (text) => {
                if (!text.trim()) return;
                socketRef.current.send({ type: 'CHAT', text, senderName: myName, senderId: myId });
            };

            // --- UI RENDER ---

            if (view === "lobby") return <Lobby onHost={(n) => initPeer(n, generateRoomId(), true)} onJoin={(id, n) => initPeer(n, id, false)} isConnecting={status.includes("Menghubungkan")} />;

            const isDrawer = myId === gameState.drawerId;
            const hiddenWord = gameState.word.replace(/[a-zA-Z]/g, "_ ");

            return (
                <div className="flex flex-col h-screen max-w-6xl mx-auto bg-gray-50 shadow-2xl">
                    {/* Header */}
                    <div className="bg-white p-4 shadow flex justify-between items-center z-10">
                        <div className="flex items-center gap-4">
                            <div className="bg-gray-800 text-white w-12 h-12 rounded-full flex items-center justify-center font-bold text-xl">{gameState.timer}</div>
                            <div>
                                {gameState.phase === 'playing' ? (
                                    isDrawer ? 
                                    <div className="text-xl font-bold text-green-600">GAMBAR: {gameState.word}</div> : 
                                    <div className="text-xl font-mono tracking-widest bg-gray-200 px-2 rounded">{hiddenWord}</div>
                                ) : <div className="text-gray-500">Menunggu ronde...</div>}
                            </div>
                        </div>
                        <div className="text-xs text-gray-400 font-mono">Room: {gameState.roomId}</div>
                    </div>

                    <div className="flex flex-1 overflow-hidden">
                        {/* Player List */}
                        <div className="w-48 bg-white border-r p-2 overflow-y-auto hidden md:block">
                            <div className="text-xs font-bold text-gray-400 mb-2">PEMAIN ({gameState.players.length})</div>
                            {gameState.players.sort((a,b)=>b.score-a.score).map(p => (
                                <div key={p.id} className={`flex items-center p-2 rounded mb-1 ${p.id === gameState.drawerId ? 'bg-yellow-50 border border-yellow-200' : 'bg-gray-100'}`}>
                                    <div className="w-8 h-8 rounded-full bg-blue-100 flex items-center justify-center text-xs font-bold mr-2">{p.name[0]}</div>
                                    <div className="overflow-hidden">
                                        <div className="font-bold text-sm truncate">{p.name}</div>
                                        <div className="text-xs text-gray-500">{p.score} Pts</div>
                                    </div>
                                    {p.id === gameState.drawerId && <i className="fa-solid fa-pencil text-yellow-500 ml-auto"></i>}
                                </div>
                            ))}
                        </div>

                        {/* Main Canvas */}
                        <div className="flex-1 bg-gray-200 p-4 flex flex-col relative">
                            {/* Result Overlay */}
                            {gameState.phase === 'result' && (
                                <div className="absolute inset-0 bg-black/80 z-20 flex flex-col items-center justify-center text-white">
                                    <div className="text-2xl mb-2">Jawabannya:</div>
                                    <div className="text-4xl font-bold text-green-400 mb-4">{gameState.word}</div>
                                    <div className="text-sm animate-pulse">Ronde berikutnya dalam {gameState.timer}...</div>
                                </div>
                            )}

                            {gameState.phase === 'waiting' && isHost && (
                                <div className="absolute inset-0 bg-white/90 z-20 flex items-center justify-center">
                                    <button onClick={startGame} className="bg-green-600 hover:bg-green-700 text-white text-xl font-bold py-4 px-8 rounded-xl shadow-lg">
                                        MULAI GAME
                                    </button>
                                </div>
                            )}

                            <div className="flex-1 bg-white rounded shadow-lg overflow-hidden mb-2 border-2 border-gray-300">
                                <CanvasBoard 
                                    isDrawer={isDrawer && gameState.phase === 'playing'}
                                    color={brushColor}
                                    width={brushSize}
                                    socket={socketRef.current}
                                    gameState={gameState}
                                />
                            </div>

                            {/* Tools */}
                            {isDrawer && gameState.phase === 'playing' && (
                                <div className="bg-white p-2 rounded shadow flex justify-between items-center">
                                    <div className="flex gap-1">
                                        {['#000000', '#ef4444', '#22c55e', '#3b82f6', '#eab308'].map(c => (
                                            <button key={c} onClick={() => setBrushColor(c)} className={`w-8 h-8 rounded-full border-2 ${brushColor === c ? 'border-gray-800 transform scale-110' : 'border-transparent'}`} style={{backgroundColor: c}} />
                                        ))}
                                    </div>
                                    <div className="flex items-center gap-2">
                                        <input type="range" min="2" max="20" value={brushSize} onChange={(e) => setBrushSize(parseInt(e.target.value))} className="w-24" />
                                        <button onClick={() => socketRef.current.send({type: 'CLEAR'})} className="text-red-500 hover:bg-red-50 p-2 rounded"><i className="fa-solid fa-trash"></i></button>
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* Chat */}
                        <div className="w-72 bg-white border-l flex flex-col">
                            <div className="p-3 bg-gray-50 border-b font-bold text-gray-700">Chat</div>
                            <div className="flex-1 overflow-y-auto p-2 space-y-2 flex flex-col-reverse">
                                {[...gameState.chat].reverse().map((msg, i) => (
                                    <div key={i} className={`text-sm p-2 rounded ${msg.type === 'system' ? 'bg-blue-50 text-blue-800 text-center text-xs font-bold uppercase' : msg.type === 'success' ? 'bg-green-100 text-green-800 text-center font-bold' : 'bg-gray-100'}`}>
                                        {msg.type === 'user' && <span className="font-bold text-gray-700">{msg.senderName}: </span>}
                                        {msg.text}
                                    </div>
                                ))}
                            </div>
                            <div className="p-2 border-t">
                                <input 
                                    type="text" 
                                    placeholder={isDrawer ? "Anda menggambar!" : "Tebak di sini..."}
                                    className="w-full border rounded px-3 py-2 disabled:bg-gray-100"
                                    disabled={isDrawer && gameState.phase === 'playing'}
                                    onKeyDown={(e) => { if(e.key === 'Enter') { sendChat(e.target.value); e.target.value = ''; } }}
                                />
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById("root"));
        root.render(<App />);
    </script>
</body>
</html>
